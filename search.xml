<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>nfls做题细节</title>
      <link href="/2024/09/30/nfls%E5%81%9A%E9%A2%98%E7%BB%86%E8%8A%82/"/>
      <url>/2024/09/30/nfls%E5%81%9A%E9%A2%98%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<p>这几天在 nflsoj 上做题，其中有来源广泛的题。虽然是原题，但搬题人对于大多数题目都总结了形式化题意，且自造了数据。数据虽然有些很水，但也有些十分用心，时限的设置也是否用心。于是有了这篇文章，记录我做题时遇到的细节。</p><h3 id="常数类"><a href="#常数类" class="headerlink" title="常数类"></a>常数类</h3><ol><li>倍增数组要写成 <code>arry[__lg(N)+1][N]</code> 的形式，而不是 <code>arry[N][__lg(N)+1]</code> 。前面的写法可以有效减少指针移动距离，减少常数。是的，有道题我因为这个被卡常了。</li><li>使用扩大后会定期重构的 hash 容器时查询使用 <code>.find()</code> 函数而不是使用<code>[]</code>运算符。后者无论 hash 表中是否存在这个元素都会插入这个元素。</li></ol><h3 id="正确性类"><a href="#正确性类" class="headerlink" title="正确性类"></a>正确性类</h3><ol><li>注意搞清 dfn 序和编号，题目大多求满足同样限制下编号最小而不是 dfn 序最小。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> oi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解：P5619_[DBOI2019]__持矢</title>
      <link href="/2024/09/20/%E9%A2%98%E8%A7%A3%EF%BC%9AP5619%20%5BDBOI2019%5D%20%E6%8C%81%E7%9F%A2/"/>
      <url>/2024/09/20/%E9%A2%98%E8%A7%A3%EF%BC%9AP5619%20%5BDBOI2019%5D%20%E6%8C%81%E7%9F%A2/</url>
      
        <content type="html"><![CDATA[<p>根据期望的线性性，设每个点得分期望为 $p_i$，则 $p_i&#x3D;(\frac{1}{2}+\frac{score_i}{2})\times \displaystyle\prod_{j\in son_i}p_j$。发现一个问题，这样计算的话所有点都没射中的情况会对答案有 $\frac{1}{可能结果数}$ 的贡献，但实际它的贡献为 0 ，所以 $ans_i&#x3D;p_i-\frac{1}{2^siz_i}$，其中$siz_i$ 为 $i$ 的子树大小。</p><p>然后树形 dp 求出答案即可，这是会发现一个问题，交上去全 MLE 了。</p><p>为什么呢？两个数组是一定没有问题的，那么问题就出在了 vector 上。因为 vector 本身五元素就占据一定空间且在扩容后会预留 1.5 或 2 倍空间，只能是 vector 导致 MLE 了。但 vector 封装的很好，想要减少空间几乎是不可能的，于是就只能手写一个 vector 了。手写 vector 自身所占空间极小，在读入完成后还可以把预留的空间全部释放，这样空间就是严格的 $3\times n+m​$ 倍了。卡时间常数可以使用 barret 约减快速取模并预处理 2 的逆元。</p><p>下面附上使用 vector 的代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">const int N = 2e6+1,mod=19260817;</span><br><span class="line">int n,m;</span><br><span class="line">struct Barret&#123;</span><br><span class="line">    long long m,p;</span><br><span class="line">    void init(int pp)&#123;m=((__int128)1&lt;&lt;64)/pp;p=pp;&#125;</span><br><span class="line">    long long operator ()(long long x)&#123;</span><br><span class="line">        return x-((__int128(x)*m)&gt;&gt;64)*p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Ba;</span><br><span class="line">struct vectorr</span><br><span class="line">&#123;</span><br><span class="line">signed *p;</span><br><span class="line">signed siz,maxsiz;</span><br><span class="line">vectorr()</span><br><span class="line">&#123;</span><br><span class="line">p=new signed[2];</span><br><span class="line">maxsiz=2;</span><br><span class="line">&#125;</span><br><span class="line">inline void nnew()</span><br><span class="line">&#123;</span><br><span class="line">signed *p1=p;</span><br><span class="line">maxsiz*=1.77;</span><br><span class="line">p=new signed[maxsiz];</span><br><span class="line">memcpy(p,p1,siz&lt;&lt;2);</span><br><span class="line">delete p1;</span><br><span class="line">&#125;</span><br><span class="line">inline void push_back(signed x)</span><br><span class="line">&#123;</span><br><span class="line">if(siz&gt;=maxsiz-1)</span><br><span class="line">&#123;</span><br><span class="line">nnew();</span><br><span class="line">&#125;</span><br><span class="line">p[siz++]=x;</span><br><span class="line">&#125;</span><br><span class="line">inline signed&amp; operator[](signed x)</span><br><span class="line">&#123;</span><br><span class="line">if(x&gt;=siz)return siz;</span><br><span class="line">return p[x];</span><br><span class="line">&#125;</span><br><span class="line">inline signed* begin()</span><br><span class="line">&#123;</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br><span class="line">inline signed* end()</span><br><span class="line">&#123;</span><br><span class="line">return p+siz;</span><br><span class="line">&#125;</span><br><span class="line">inline void era()</span><br><span class="line">&#123;</span><br><span class="line">if(siz==0)return;</span><br><span class="line">siz--;</span><br><span class="line">&#125;</span><br><span class="line">void ok()</span><br><span class="line">&#123;</span><br><span class="line">signed *p1=p;</span><br><span class="line">maxsiz=siz;</span><br><span class="line">p=new signed[maxsiz];</span><br><span class="line">memcpy(p,p1,siz&lt;&lt;2);</span><br><span class="line">delete p1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vectorr a[N];</span><br><span class="line">signed qpow(long long x,signed y)</span><br><span class="line">&#123;</span><br><span class="line">int res=1;</span><br><span class="line">while(y)</span><br><span class="line">&#123;</span><br><span class="line">if(y&amp;1)res=Ba(res*x);</span><br><span class="line">x=Ba(x*x);</span><br><span class="line">y&gt;&gt;=1;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">signed f[N];</span><br><span class="line">signed siz[N];</span><br><span class="line">const int ttt=9630409;</span><br><span class="line">void dfs(signed x,signed fa)</span><br><span class="line">&#123;</span><br><span class="line">siz[x]=1;</span><br><span class="line">int son=1;</span><br><span class="line">for(auto i:a[x])</span><br><span class="line">&#123;</span><br><span class="line">if(i==fa)continue;</span><br><span class="line">dfs(i,x);</span><br><span class="line">son=Ba(son*f[i]);</span><br><span class="line">siz[x]+=siz[i];</span><br><span class="line">&#125;</span><br><span class="line">f[x]=Ba(son*ttt+son*ttt*f[x]);</span><br><span class="line">&#125;</span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);</span><br><span class="line">Ba.init(mod);</span><br><span class="line">signed tmp;</span><br><span class="line">cin&gt;&gt;tmp;</span><br><span class="line">n=tmp;</span><br><span class="line">cin&gt;&gt;tmp;</span><br><span class="line">m=tmp;;</span><br><span class="line">for(signed i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;tmp;</span><br><span class="line">f[i]=tmp;</span><br><span class="line">&#125;</span><br><span class="line">int x,y;</span><br><span class="line">for(signed i=1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;tmp;</span><br><span class="line">x=tmp;</span><br><span class="line">cin&gt;&gt;tmp;</span><br><span class="line">y=tmp;</span><br><span class="line">a[x].push_back(y);</span><br><span class="line">a[y].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i].ok();</span><br><span class="line">&#125;</span><br><span class="line">dfs(1,0);</span><br><span class="line">int ans=0;</span><br><span class="line">for(signed i=1;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;tmp;</span><br><span class="line">x=tmp;</span><br><span class="line">ans=Ba(ans+Ba(f[x]-qpow(qpow(2,siz[x]),mod-2))+mod);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;(long long)ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目名称好评，建议去做这次比赛的另一道题捡币。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解：P9963_[THUPC_2024_初赛]_前缀和</title>
      <link href="/2024/09/20/%E9%A2%98%E8%A7%A3%EF%BC%9AP9963%20%5BTHUPC%202024%20%E5%88%9D%E8%B5%9B%5D%20%E5%89%8D%E7%BC%80%E5%92%8C/"/>
      <url>/2024/09/20/%E9%A2%98%E8%A7%A3%EF%BC%9AP9963%20%5BTHUPC%202024%20%E5%88%9D%E8%B5%9B%5D%20%E5%89%8D%E7%BC%80%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>好题。</p><p>考虑每个数对答案的贡献，设出现数字 $i$ 的概率为 $p_i$（同时题目中给定的 $p$ 设为 $p’$） ，那么</p><p>$$ p_i&#x3D; \begin{cases}  1 &amp; (i&#x3D;0) \\ \displaystyle\sum_{j&#x3D;0}^i p_j\times (1-p’)^{i-j-1} \times p’ &amp; (other)   \end{cases}​$$</p><p>打表可以对于所有 $i \not &#x3D;0,p_i&#x3D;p’​$ ，那么如何严格地证明呢？</p><p>发现从$0$贡献到另一个数，无论中间过程怎样，只要加上的数的数量相同，最后贡献到的概率都是相同的。也就是说，对于每一种可能的贡献方式，设步数为$x$，$p_j$ 都应当加上 $1\times (1-p’)^{j-x}\times p’^x$ ，将一个整数 $j$ 划分成 $x$ 个正整数的方案数为 $\binom{j-1}{x-1}$ 。所以</p><p>$$p_i &#x3D;\displaystyle\sum_{j&#x3D;1}^i(1-p’)^{i-j}\times p’^j \binom{i-1}{j-1} (i\not &#x3D;0)​$$</p><p>让我们尝试化简它，先设</p><p>$$h_{k} &#x3D;\displaystyle\sum_{j&#x3D;0}^{i}(1-p’)^{i-j}\times p’^{j+1} \binom{i}{j}​$$</p><p>那么</p><p>$$h_i&#x3D;p_{i+1}​$$</p><p>发现比较像二项式反演的式子，那么记</p><p>$$f_{j}&#x3D;(1-p’)^{i-j}\times p’^{j+1}​$$</p><p>所以</p><p>$$h_i&#x3D;\displaystyle\sum_{j&#x3D;0}^{i}\binom{i}{j}f_{j}​$$</p><p>发现没用，于是</p><p>$$ans&#x3D;\displaystyle\sum_{i&#x3D;l}^r\displaystyle\sum_{j&#x3D;1}^{1}(1-p’)^{i-j}\times p’^j \binom{i-1}{j-1}$$</p><p>还是没用，但是设 $l&#x3D;i-j$</p><p>$$h_i&#x3D;\displaystyle\sum_{l&#x3D;0}^i(1-p’)^l\times p’^{i-l+1}\binom{l+j}{j}$$</p><p>即</p><p>$$h_i&#x3D;\displaystyle\sum_{l&#x3D;0}^i(1-p’)^l\times p’^{i-l+1}\displaystyle\prod_{o&#x3D;1}^l\frac{l+o}{o}​$$</p><p>可以化为</p><p>$$h_i&#x3D;\displaystyle\sum_{l&#x3D;0}^i p’^{i+1}\displaystyle\prod_{o&#x3D;1}^l\frac{(l+o)\times (1-p’)}{o\times p’}​$$</p><p>提出来</p><p>$$h_i&#x3D;p’^{i+1}\displaystyle\sum_{l&#x3D;0}^i (\frac{1-p’}{p’})^l\binom{l+j}{j}$$</p><p>发现回来了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stable_diffusion心得</title>
      <link href="/2024/09/18/stable_diffusion%E5%BF%83%E5%BE%97/"/>
      <url>/2024/09/18/stable_diffusion%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<p>stable_diffusion 真的有不少坑，这篇文章说是心得，但我觉得更像一个踩坑记录。</p><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入<a id="引入"></a></h3><p>首先介绍一下两种图形化界面的工具，毕竟如果不是深入学习过要追求效率以及自动化的话，还是图形化界面更合适。图形化界面主流的有两种，分别是基于 webui 的 <a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui">AUTOMATIC1111 &#x2F; stable-diffusion-webui</a> 和 <a href="https://github.com/comfyanonymous/ComfyUI">comfyanonymous &#x2F; ComfyUI</a> 。因为这两种工具大小都不大，但都有各自的优劣，可以同时下载两种工具并共享模型，根据需要切换工具。但是这两给工具都只支持 NVIDIA 显卡 ，所以如果你没有独显的话建议使用 <a href="https://github.com/openvinotoolkit/stable-diffusion-webui">带有 openvino 加速的 webui</a>。配置好后使用 Intel 显卡加速可以显著加快图片生成速度，具体可以跳转到下面的 <a href="#openvino">openvino</a>。</p><h3 id="模型配置"><a href="#模型配置" class="headerlink" title="模型配置"></a>模型配置</h3><p>首先认识一下不同模型。</p><ol><li><p>stable_diffusion : 主模型，最大，作画主要靠它</p></li><li><p>VAE : 风格引导，此选项不正确会导致花图，就是图片像丙烯画一样。注意一些主模型自带 VAE ，还有一些有配套 VAE ，下载模型时要看清楚。</p></li><li><p>lora : 语言处理，顾名思义，对文本理解与它有关。</p><p>主要模型就这三种，其余大多是变种或小优化（预处理）之类的，想了解可以去看官方文档。</p></li></ol><h3 id="openvino"><a href="#openvino" class="headerlink" title="openvino"></a>openvino<a id="openvino"></a></h3><p>要使用 openvino 的话首先最好先直接下载<a href="#%E5%BC%95%E5%85%A5">引入</a>中的 openvino 版 webui ，当然也可以将 openvino 作为插件使用。注意，据我查找到的资料，目前原生 comfyui 并不支持 openvino ，所以只能使用 webui 。准备好后打开 webui 脚本&#x2F;script 处选择 使用 openvino 加速后就可以开启 openvino ，硬件建议选择 GPU ，其他按需选择即可。如果你有报错，先切换到一个低版本 sd 的小模型，如果还是不行就把 pytorch 降级为 2.0.1 ，如果还不行我就没办法了。据我使用情况，sd3.0 的模型基本一张图 22 秒左右。但目前我无法对 sdxl 模型使用 openvino 加速，报错一大堆，还要在研究一下。</p><p>in queue <a href="https://github.com/lllyasviel/stable-diffusion-webui-forge">lllyasviel&#x2F;stable-diffusion-webui-forge (github.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> stable_diffusion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用</title>
      <link href="/2024/09/15/%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/09/15/%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="72292b0b5cbd93a81e129a1bf87923d64b5e02c83ffb5122fab27a47cd7543bd">48bf2b3dc5748a452040de3ea53899a1dae055ffa521280a0fb46f80be4efd920253b2d348fc4089e3cf573a0832b8ea0ad68a72b6db74420390cb2fec6f33d3c55832330178ce01e7a9a994307fb7ab88a947188fe8b58dc5012f82fa32eb5205c2990721d2569f9171b78cc394345905c22c1f1bf736d343f4bd0285cbe89db405bf09768babbf1061d667fe5e2e3d39a2e1f24c0f2fbd4f6d8c820fbf456a50711354ffb96a32ef9608039748b5bff5f16bcae68ae288efa51d6e02f278d01f7ba162cebddaa807d213f43d54c0b0ce6aba382d29c5a5e37f1e5a895caf0c5749c19626e8cd4f26e1ce5a8e7db19ade7f2b80a509e0c81ffce421c0d5ed52c74a317c14699292e5e66f72138b1ff7db3816af3495854ecc55c7ad439c6096a95209b30dc53d1649c4ca01901f71e1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">hugoi's npy(bushi)</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tips</title>
      <link href="/2024/09/13/tips/"/>
      <url>/2024/09/13/tips/</url>
      
        <content type="html"><![CDATA[<p>如果 mathjax 不能正常显示 <code>ctrl+F5</code> 刷新。</p><p><a href="/zyh/url">url</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>题解：P4959_[COCI2017-2018#6]_Cover</title>
      <link href="/2024/09/11/%E9%A2%98%E8%A7%A3%EF%BC%9AP4959%20%5BCOCI2017-20186%5D%20Cover/"/>
      <url>/2024/09/11/%E9%A2%98%E8%A7%A3%EF%BC%9AP4959%20%5BCOCI2017-20186%5D%20Cover/</url>
      
        <content type="html"><![CDATA[<p>发现可以将所有点转换到第一象限上，这样问题就转化成了选定一些矩形覆盖所有的点，矩形的一个顶点位于原点。发现一些点具有如下性质，覆盖这个点的矩形一定覆盖到其他几个点，如覆盖 $A(10,10)$ 就一定会覆盖 $B(1,1)$ 此时像 $B$ 这样的点就可以不考虑，最后要考虑的点形成一个二维偏序形式，对于点 $i$ 有 $ x_{i+1}&gt;x_i,y_{i+1}&lt;y_i$，称要考虑的点为关键点，对这些点按横坐标排序。</p><p>然后就可以设计 dp 状态了，设 $f_i$ 表示区间 $[i,n]$ 的关键点都被覆盖，其余关键点没被覆盖的答案，转移是每次枚举一个高度 $y$ 并用 $f_{i+1}$ 加上 $y\times x_i$ 更新 $f_j$ ，下标为 $j$ 的点是第一个纵坐标值小于等于 $y$ 的点。 </p><p>注意离散化。</p><p>code:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">const int N = 6000;</span><br><span class="line">struct ma</span><br><span class="line">&#123;</span><br><span class="line">int x,y;</span><br><span class="line">&#125;p[N],pp[N];</span><br><span class="line">bool cmp(ma x,ma y)</span><br><span class="line">&#123;</span><br><span class="line">if(x.x!=y.x)return x.x&gt;y.x;</span><br><span class="line">return x.y&gt;y.y;</span><br><span class="line">&#125;</span><br><span class="line">int xx[N],yy[N];</span><br><span class="line">int n;</span><br><span class="line">int tot;</span><br><span class="line">int hi;</span><br><span class="line">int f[N];</span><br><span class="line">int to[N];</span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">int x,y;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">x=abs(x),y=abs(y);</span><br><span class="line">xx[i]=x;</span><br><span class="line">yy[i]=y;</span><br><span class="line">p[i]=&#123;x,y&#125;;</span><br><span class="line">&#125;</span><br><span class="line">sort(xx+1,xx+1+n);</span><br><span class="line">sort(yy+1,yy+1+n);</span><br><span class="line">int cnt,cnt1;</span><br><span class="line">cnt=unique(xx+1,xx+1+n)-xx-1;</span><br><span class="line">cnt1=unique(yy+1,yy+1+n)-yy-1;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">p[i]=&#123;lower_bound(xx+1,xx+1+cnt,p[i].x)-xx,</span><br><span class="line">  lower_bound(yy+1,yy+1+cnt1,p[i].y)-yy,&#125;;</span><br><span class="line">&#125;</span><br><span class="line">sort(p+1,p+1+n,cmp);</span><br><span class="line">int ans=0;</span><br><span class="line">memset(to,0x3f,sizeof to);</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(p[i].y&gt;hi)</span><br><span class="line">&#123;</span><br><span class="line">hi=p[i].y;</span><br><span class="line">pp[++tot]=p[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">reverse(pp+1,pp+1+tot);</span><br><span class="line">for(int i=1;i&lt;=tot;i++)</span><br><span class="line">&#123;</span><br><span class="line">to[pp[i].y]=min(to[pp[i].y],i);</span><br><span class="line">&#125;</span><br><span class="line">memset(f,0x3f,sizeof f);</span><br><span class="line">f[tot+1]=0;</span><br><span class="line">for(int i=tot;i&gt;=1;i--)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=pp[i].y;j&lt;=cnt1;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(to[j]&gt;1e6)continue;</span><br><span class="line">f[to[j]]=min(f[to[j]],f[i+1]+yy[j]*xx[pp[i].x]*4);</span><br><span class="line">&#125;</span><br><span class="line">for(int j=2;j&lt;=tot;j++)</span><br><span class="line">&#123;</span><br><span class="line">f[i]=min(f[i-1],f[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>omori</title>
      <link href="/2024/09/09/omori/"/>
      <url>/2024/09/09/omori/</url>
      
        <content type="html"><![CDATA[<h3 id="甜心城堡"><a href="#甜心城堡" class="headerlink" title="甜心城堡"></a>甜心城堡</h3><p>先从这说起吧。</p><p>进来之前和 wyj 玩时通过回档把四个季节鼹鼠的成就都拿了。</p><p>进来之后被关地牢了，一直想去按那两个按钮（结果是解锁后续剧情才能按），在这两个地方包括地牢里逛了好长时间，后来因为两个任务没做卡关了（有个任务没注意，过了一些剧情有不会做的任务就没去做（没看清任务没结束））。后来就瞎逛了，2024-9-8 路上实在没意思，就进了两次战斗，这时 omori 已经没能量了，有的人掉了点血（不超过20），hero 能量 80 左右。然后就到乐团了，我对这里有些印象，想起这里可能还有些任务，就去接了。不知道任务具体要求是什么，反正我尽量浪费最少投掷物，及时“叫醒”鼹鼠就过了（虽然第一轮基本等同于瞎点）。因为没回能量，我边打边祈祷等会儿不会进 boss 战。</p><p>然后出门没进 boss 战，我一边窃喜一边朝地牢里的果篮狂奔，然后走几步就遇见爵士三世了。团队如下：omori 和 aubrey 16级，kal 和 hero 15 级，但 omori 能量 13 ，不能使用乱砍输出，所以基本思路还是攒连携技。一路稳扎稳打，hero 回血，其余输出，偶尔使用点心，血量基本都维持在 95 以上。就在能放连携的前一轮，爵士一个红温直接 98 伤害干没一个人，这时候爵士有小半管血，不用连携不知道能不能打过（没一个人后阵型会乱，可能会有位置空缺，容易寄），于是用生命果酱复活了一个人。后来慢慢磨，就过了。</p><p>出了城堡到了甜心的花园，有一些小解密。有个地道下去会遇见一堆熊在牢笼里，地道尽头有按钮，因为刚存完档，所以经过作者再三警告后我还是放出了熊。但我没想到熊会直接冲我啊，直接把去路堵死，逃跑都不行，还不好打，虽然群体攻击不多，但一击目前最高打出了 258 ，能直接秒任何一个人，十分难打。不过在我的努力下我还是击败三只熊，抓住缺口再加上逃跑的无法锁定逃了出来。感觉比较强。</p><p>后来集齐了四个密码（开始还以为是困难解密，后来发现只是在简单对话中），到雕像输入密码通过地道回到了大堂。</p><p>经过一番鼹鼠麦克的演讲后，甜心和甜心自己的婚礼要开始了。进行过程中（好像是） aubrey 看不下去打断了婚礼，然后就又进 boss 战了。甜心还是比较难打的，中间误使用了一次技能浪费了一点能量，导致连携使用时间比较靠后，好在 hero 能量够多，用完连携甜心才 111 伤害干没一个人（好像是 kal）。连携打出“疲软一击”，好像只有 400 伤害（正常 1000），用完以后甜心还有半管血，但我不想重打，于是又慢慢消耗。得益于 aubrey 前期重击技能破盾减抗，加上 hero 消除己方效果，后期伤害比较可观，最后打败甜心。打败甜心之后太空海盗男孩（或者叫太空前男友）开飞船与甜心复合，这一段流程基本结束。</p><p>后来 omori 进入了一个地洞一样的地方，掉落过程中与朋友失散，独自来到一个森林。森林里光线很暗，蛛网也比较多，周围有一些回忆，都是关于 mari 死后 omori 在学校期间的回忆以及部分 omori 在家后的回忆。最后遇见了一个老蘑菇，老蘑菇说我是它的同类，花钱后老蘑菇教了 omori 一个技能，并让 omori 解救另一个不能自己脱离束缚的同类，这里束缚是一个类似花苞一样的东西。最后解救出了新生的蘑菇，然后忘了，最后梦醒回到了现实。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>会有人来看吗</title>
      <link href="/2024/09/08/%E4%BC%9A%E6%9C%89%E4%BA%BA%E6%9D%A5%E7%9C%8B%E5%90%97/"/>
      <url>/2024/09/08/%E4%BC%9A%E6%9C%89%E4%BA%BA%E6%9D%A5%E7%9C%8B%E5%90%97/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="353bea8638ff33602c018f7ad24bf7ca05d914d86bd94727b9d1d822bc81164c">5c5c50b7b1c74a82eb1f78067f555319c4d7382f43fde9cc6ffd6fa4e6553d3cdcdf68e3e2cdd1e10203bd33e9efd18bf92db870bb5857708a287c7821ad3f34475c3fba268290b5d083736a4f7f8195cb726e86277333253ee0b26fc23c0d7635fc63bec150bbde0c59a70f92de77be2cb789bab3b199611efdd6f29d50381638e83fc974e5ad0be6d3358cf91db68161e7b7688a5cc1d130c7db0087facdd059d95e348fd34db264976aaea584f37088cd6af55d14ac72c728e36ea68237e7a57974fc759475ba87d4bad58a9f2b221d76ea4db773c2bd85040ea493c0d249490e0dc958edc9013681afea3b21a99b3c0bd7b467d8588a858628e0017fc3163300567e53d60438dc471237929209b99a716c92a6f5771deee9e98ab88c21b388aee279a362cb399f8dd59c33378f971cda39dcdfc3284c65d2f5fa37ab6e59766155d9deb97e4418afcc5317c1135eaf8c4f6fdf144fa89beb95834f60c3f4990521270c14b55076458c8f6d343f952519adfe209b37ac9a9ee603a9468001017f87ac729bcc97f034a950a5b317cbec13c149c5cf57109bf369fe5a93f85ac7458fb648ac95cf41f384585acf38a48da4a95a43b4bd0156fc27eae54bd1264728d6a5462af8c3514854cc52652662c722fa29b3ed2f5c924bac6aaadc0f0f148fc14d1eda6abd7475409a58803d0d10cbe6f99e5a899a2b5e1edcc848cdc5c26c792f5cee4ca7189e81d1fc4cc9328e0269dbba552b8014fca8e9180320b7797d6d51a5a6169b11c031f2c947e9eb4543d6d8d5d8556543377a5149d402e929d0658875ef516f6c7e84f145874e195d220c045ad9ee2ab2f4a0f3542746f83189d3e46416acc48627bb0ab500df3ef3474c5e0dda4a956224c91f9c58d479f03cfe94a2307d7553e457f42d6f48d61507706fb6151016b51c2e9c691096e12efa60eb40123f9f51de9e28958c88e9cf9a6c76fe9f176e51b6698a4bd03e1144e951c98a7447f25bd8f6b31d2c7564e6cd33a70105001530e4144da53fc37205a4fe7174b0663865452c91daeaf5f605b95ea432754717bc3efb2d50cb7bc90e7ffb5665e8b90c68b803bfc9247d4012e82d98aa1b94e9d532af5a83b80b315e953a8490535f2639b5d875d067537cb6650cd1bf1e5da2c58399d0a930c371087bdf126a3a4a6d914155c4d959a03368860f9ddd8b54a54e43eede3286a67fc0a00cda0ae7b4388127b79164f3eaa8abc56db914c9035d33845be8cb31c7053aae3a1df9bd7d278e31b269ac02fc017b386b8c1978622e51368facaa95f7686ab0d0b3030a40860d98ea768e59a11ccb39d1a77828bd8d563767e52b99a7576062085d74913b5f9f34604b471873ca36f4fbdadd4cf33c447333981b00ab7a61287e8a7a6d4b6baed5a0262f54def2dc3d9dab031a16939998a73214b51776</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">hugoi's npy(bushi)</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> oi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解：AT_joisc2015_i_とてもたのしいカードゲーム</title>
      <link href="/2024/09/06/%E9%A2%98%E8%A7%A3%EF%BC%9AAT_joisc2015_i%20%E3%81%A8%E3%81%A6%E3%82%82%E3%81%9F%E3%81%AE%E3%81%97%E3%81%84%E3%82%AB%E3%83%BC%E3%83%89%E3%82%B2%E3%83%BC%E3%83%A0/"/>
      <url>/2024/09/06/%E9%A2%98%E8%A7%A3%EF%BC%9AAT_joisc2015_i%20%E3%81%A8%E3%81%A6%E3%82%82%E3%81%9F%E3%81%AE%E3%81%97%E3%81%84%E3%82%AB%E3%83%BC%E3%83%89%E3%82%B2%E3%83%BC%E3%83%A0/</url>
      
        <content type="html"><![CDATA[<p>挺不错的一道题，但校内 oj 空间只开了 512 MB ，赛时虽然有勇气写出正解的思路，但只能通过开小数组获得部分分。</p><p>数据范围一眼 $n^3$ dp 。因为只会取走当前第三张牌以上的牌，且这样的牌最多只有两张，很容易想到分别记录第一，二，三张牌位置作为状态，发现不好转移，于是增设一维状态，用 0 1 2 表示能不能选当前的第一张和能不能选当前的第三张，以及是否可以都选。</p><p>发现状态数很少，适合使用记忆化搜索。</p><p>考虑状态转移，如果当前选第一张，那么第二张变成第一张，第三张变成第二张，第三张后面一张变成第三张，即：</p><p>$$f_{x,y,z}&#x3D;f_{y,z,z+1}+v_x$$</p><p>如果选第三张同理，即:</p><p>$$f_{x,y,z}&#x3D;f_{x,y,z+1}+v_z$$</p><p>用辅助函数 <code>to</code> 计算下次能不能选第一张和第三张。</p><p>空间卡的很死，再大就不能过编了。</p><p>code</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 510;</span><br><span class="line">int n;</span><br><span class="line">int f[N][N][N][3];</span><br><span class="line">bool v[N][N][N][3];</span><br><span class="line">struct card</span><br><span class="line">&#123;</span><br><span class="line">int c,a,v;</span><br><span class="line">&#125;a[N];</span><br><span class="line">int cnt;</span><br><span class="line">inline int to(int x,int z,int xx)</span><br><span class="line">&#123;</span><br><span class="line">int res=0;</span><br><span class="line">if(x&lt;=n&amp;&amp;xx&lt;=n)if(a[x].c==a[xx].c||a[x].a==a[xx].a)res|=1;</span><br><span class="line">if(z&lt;=n&amp;&amp;xx&lt;=n)if(a[z].c==a[xx].c||a[z].a==a[xx].a)res|=2;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">inline int dfs(int x,int y,int z,int st)</span><br><span class="line">&#123;</span><br><span class="line">if(st==0||x&gt;=y||y&gt;=z||x&gt;=z)return 0;</span><br><span class="line">if(v[x][y][z][st-1])return f[x][y][z][st-1];</span><br><span class="line">v[x][y][z][st-1]=1;</span><br><span class="line">int res=0;</span><br><span class="line">if(st&amp;1)res=max(res,dfs(y,z,z+1,to(y,z+1,x))+a[x].v);</span><br><span class="line">if((st&amp;2)&amp;&amp;z&lt;=n)res=max(res,dfs(x,y,z+1,to(x,z+1,z))+a[z].v);</span><br><span class="line">f[x][y][z][st-1]=res;</span><br><span class="line">return f[x][y][z][st-1];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">int x,y,z;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">a[i]=&#123;x,y,z&#125;;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;max(dfs(2,3,4,to(2,4,1))+a[1].v,dfs(1,2,4,to(1,4,3))+a[3].v)&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解：P6345_[CCO2017_接雨滴</title>
      <link href="/2024/09/06/%E9%A2%98%E8%A7%A3%EF%BC%9AP6345%20%5BCCO2017%5D%20%E6%8E%A5%E9%9B%A8%E6%BB%B4/"/>
      <url>/2024/09/06/%E9%A2%98%E8%A7%A3%EF%BC%9AP6345%20%5BCCO2017%5D%20%E6%8E%A5%E9%9B%A8%E6%BB%B4/</url>
      
        <content type="html"><![CDATA[<p>首先发现可以把一些柱子放在右侧形成一个递减序列从而使这些柱子对答案没有贡献。</p><p>考虑每个柱子可以接到多少雨，第 $i$ 根柱子，这根柱子上方接到雨量为 $\min{ \displaystyle\max _{j&#x3D;0}^ih_j, \displaystyle\max _{j&#x3D;i}^nh_j }$。</p><p>因为每根柱子都可以插入在任意两根柱子中间（如果第 $i$ 根柱子要插入的柱子左右两边已经有更高的柱子，就用这个柱子替换掉那根柱子，这样对于答案的变化量是相同的，所以不影响最终答案）所以第 $i$ 根柱子可能接到雨量为 ${h_j-h_i | h_j &gt; h_i,j\in [1,n]} \cup {0} $,然后枚举柱子进行背包转移就可以了，这种做法是 $O(n^2\times v^2)$ 的。</p><p>写出后发现转移式子中有一步是一个序列或上另一个序列左移 $x$ 位，可以 <code>bitset</code> 优化，于是最终复杂度为 $O(\frac{n^2\times v^2}{w})$。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 510;</span><br><span class="line">int n;</span><br><span class="line">int a[N];</span><br><span class="line">bitset&lt;500*50+1&gt; f[501];//背包转移</span><br><span class="line">set&lt;int&gt; ans,can;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(a+1,a+1+n);//排序取前 k - 1 大，最高柱子不会接到雨滴</span><br><span class="line">for(int i=1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">can.insert(a[i]);</span><br><span class="line">&#125;</span><br><span class="line">f[0][0]=1;</span><br><span class="line">for(int i=1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=50;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(can.find(a[i]+j)!=can.end())//有高为 a[i]+j 的柱子</span><br><span class="line">&#123;</span><br><span class="line">f[i]|=(f[i-1]&lt;&lt;(j));// 背包转移</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">f[i]|=f[i-1];</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;=n*50;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(f[n-1][i])ans.insert(i);</span><br><span class="line">&#125;</span><br><span class="line">for(auto i:ans)cout&lt;&lt;i&lt;&lt;&#x27; &#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解:AT_codefestival_2016_final_f_Road_of_the_King</title>
      <link href="/2024/08/22/%E9%A2%98%E8%A7%A3%EF%BC%9AAT_codefestival_2016_final_f%20Road%20of%20the%20King/"/>
      <url>/2024/08/22/%E9%A2%98%E8%A7%A3%EF%BC%9AAT_codefestival_2016_final_f%20Road%20of%20the%20King/</url>
      
        <content type="html"><![CDATA[<p>神仙 dp 题，蒟蒻不会做。</p><p>首先想到这是一个 $n^3$ 的 dp 。怎么想到的？当然是看数据范围了。显然，按照惯例，第一维大概率是走到了第几步。然后就不会了。不会也不能开摆，还是继续想吧。首先发现每个点都是等价的，且记录每个点的状态是很不现实的，于是我们只能考虑还存在那些状态是可以使用的。思考一圈后，发现只有 有多少点在（包含 $1$ 号点的）强连通分量中 和 走过多少点（重复经过算一次）是有用的，于是把它们加入状态。这样，我们就“凑”出了一个 $n^3$ 的 dp 。</p><p>既然状态都有了，那就考虑转移吧。发现这个状态更适合用刷表法（一定不是因为官方题解是这么干的）。先考虑第一种情况，将一个走过但不在包含 $1$ 号点的强连通分量的点加入强连通分量：</p><p>$$ f_{i+1,j,k}\gets f_{i,j,k}\times (k-j)  $$<br>有 $k-j$ 个点不在有 $1$ 的强连通分量</p><p>如果没走过下一个点</p><p>$$f_{i+1,j,k+1}\gets f_{i,j,k}\times (n-k) $$<br>剩下 $n-k$ 个点为走过</p><p>第三种情况，也是不太好想到的一种，如果下一个点在包含 $1$ 号点的强连通分量中，那么走过的就都可以与 $1$ 号点构成强连通分量</p><p>$$f_{i+1,k,k}\gets f_{i,j,k}\times j $$<br>有 $j$ 个点在含 $1$ 的强连通分量中</p><p>附上代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">const int N = 300+2,mod=1e9+7;</span><br><span class="line">int n,m;</span><br><span class="line">int f[N][N][N];</span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">f[0][1][1]=1;</span><br><span class="line">for(int i=0;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k=1;k&lt;=n;k++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=k;j++)</span><br><span class="line">&#123;</span><br><span class="line">f[i+1][j][k]+=f[i][j][k]*(k-j);</span><br><span class="line">f[i+1][j][k+1]+=f[i][j][k]*(n-k);</span><br><span class="line">f[i+1][k][k]+=f[i][j][k]*j;</span><br><span class="line">f[i+1][j][k]%=mod;</span><br><span class="line">f[i+1][j][k+1]%=mod;</span><br><span class="line">f[i+1][k][k]%=mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[m][n][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4983_忘情</title>
      <link href="/2024/08/19/%E9%A2%98%E8%A7%A3%EF%BC%9AP4983%20%E5%BF%98%E6%83%85/"/>
      <url>/2024/08/19/%E9%A2%98%E8%A7%A3%EF%BC%9AP4983%20%E5%BF%98%E6%83%85/</url>
      
        <content type="html"><![CDATA[<p>wqs二分和斜率优化已经不知道学了多少遍了，还是要写篇题解才能加深印象。</p><p>首先拆式子<br>$$w&#x3D;sum\times sum+2\times sum+1$$</p><p>$$w&#x3D;(s_i-s_{k-1})*(s_i-s_{k-1})+2\times (s_i-s_{k-1})+1$$</p><p>$$w&#x3D;s_i^2-2\times s_i\times s_{k-1}+s_{k-1}^2+2\times s_i-2\times s_{k-1}+1$$</p><p>$$s_i^2+2\times s_i+1不变$$</p><p>$$d&#x3D;s_{k-1}^2-2\times s_{k-1}$$</p><p>$$k&#x3D;2\times s_{k-1}$$</p><p>$$x&#x3D;s_i$$</p><p>可以斜率优化</p><p>但，wqs二分呢？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解：P7537_[COCI2016-2017#4]_Rima</title>
      <link href="/2024/08/13/%E9%A2%98%E8%A7%A3%EF%BC%9AP7537%20%5BCOCI2016-20174%5D%20Rima/"/>
      <url>/2024/08/13/%E9%A2%98%E8%A7%A3%EF%BC%9AP7537%20%5BCOCI2016-20174%5D%20Rima/</url>
      
        <content type="html"><![CDATA[<p>整体思路其他题解已经说的差不多了，本题解着重说一个细节问题。</p><p>首先建一棵后缀 trie ，记录每个串在树上结束的位置，这样树上每个节点（记为 $u$ ）的子树结束的串都拥有一个共同后缀（即 $u$ 到根节点所代表的串）。设 $f_i$ 表示以 $i$ 为根的最大答案，也就是答案序列中所有串都有相同后缀为 $i$ 到根节点代表的串。考虑转移，首先对于子节点，如果有串在这个点结束，可以直接继承答案，用字符串表示为 LCS +letter 与 LCS 连接（LCS 表示公共后缀），前面的序列不变。对于在其他子节点结束的串，答案加上这些串的数量（也就是则插入这些串，即 LCS+letter 与  LCS+otherletter  连接，再和 LCS 连接。）树形 dp 解决即可。</p><p>然后你写完了，信心满满地交了上去，却发现只有 $56$ 分。为什么呢？考虑下面一组数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">qpm</span><br><span class="line">pm</span><br><span class="line">m</span><br><span class="line">nm</span><br><span class="line">cnm</span><br></pre></td></tr></table></figure><p>发现可以选择整个序列，但答案只统计了下面图圈出点的答案。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/zvhl9597.png"></p><p>这是因为实际序列中字符串长度是可以先减再增的，可我们只能统计上单调减的答案。所以对于每个节点，在<strong>用这个节点更新答案时</strong>需要继承两棵最大子树的答案。</p><p>最后放上代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> trie[N][<span class="number">26</span>],f[N*<span class="number">26</span>],stop[N*<span class="number">26</span>],cnt=<span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> in[N];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> len=<span class="built_in">strlen</span>(in+<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=len;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(trie[now][in[i]-<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">&#123;</span><br><span class="line">now=trie[now][in[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">now=trie[now][in[i]-<span class="string">&#x27;a&#x27;</span>]=++cnt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">stop[now]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f[x]=stop[x];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(trie[x][i])<span class="built_in">dfs</span>(trie[x][i]);</span><br><span class="line">f[x]+=stop[trie[x][i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mx=<span class="number">0</span>,smx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(stop[trie[x][i]])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(f[trie[x][i]]-stop[trie[x][i]]&gt;mx)</span><br><span class="line">&#123;</span><br><span class="line">smx=mx;</span><br><span class="line">mx=f[trie[x][i]]-stop[trie[x][i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(f[trie[x][i]]-stop[trie[x][i]]&gt;smx)</span><br><span class="line">&#123;</span><br><span class="line">smx=f[trie[x][i]]-stop[trie[x][i]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">f[x]+=mx;</span><br><span class="line">ans=<span class="built_in">max</span>(ans,f[x]+smx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;in+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">insert</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P10862_[HBCPC2024]_Spicy_or_Grilled?</title>
      <link href="/2024/08/12/%E9%A2%98%E8%A7%A3%EF%BC%9AP10862%20%5BHBCPC2024%5D%20Spicy%20or%20Grilled/"/>
      <url>/2024/08/12/%E9%A2%98%E8%A7%A3%EF%BC%9AP10862%20%5BHBCPC2024%5D%20Spicy%20or%20Grilled/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 $n$ 个人要吃汉堡，其中 $x$ 个人吃不辣的，其余吃辣的，辣堡价格为 $a$ 元，不辣的汉堡价格为 $b$ 元，求主办方要花费多少钱。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>显然答案为 $吃辣堡的人数 \times 辣堡价格 + 吃不辣汉堡的人数 \times 不辣汉堡的价格 $。 可知吃辣堡的人数为 $n-x$。 于是答案为 $(n-x) \times a+x \times b$。</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">cin&gt;&gt;t;\\不要忘记多组数据</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n,x,a,b;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;x&gt;&gt;a&gt;&gt;b;\\输入</span><br><span class="line">cout&lt;&lt;(n-x)*a+x*b&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;\\计算答案</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解__P3447_[POI2006]_KRY-Crystals</title>
      <link href="/2024/07/10/%E9%A2%98%E8%A7%A3%EF%BC%9AP3447%20%5BPOI2006%5D%20KRY-Crystals/"/>
      <url>/2024/07/10/%E9%A2%98%E8%A7%A3%EF%BC%9AP3447%20%5BPOI2006%5D%20KRY-Crystals/</url>
      
        <content type="html"><![CDATA[<p>首先看到异或，自然想到由高到低从位数考虑。只需要默认高位能填则都填 1，如果高位全填 1 异或和不为 0 直接中止，否则用 dp 求出从这位开始可填 1 或 0 的方案数和全填 1 的方案数，再用可填 1 或 0 的方案数减去这位全为 1 的方案数（因为会重复计算）即可。</p><p>剩下的就是一些细节，首先再一些写法下 dp 过程会爆 long long ，所以记得开 <code>__int128</code>。在枚举到第 $i$ 位时，如果这位 1 的个数是偶数，需要减去全选 1 的方案数。在确定了前面的所有数时，最后一位的数也就确定了，所以不用考虑最后一个数。</p><p>其他细节见代码吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int __int128<span class="comment">//dp过程会爆long long</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">60</span>;</span><br><span class="line">ll n,a[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>];<span class="comment">//表示第i个数，当前这位（下文的j）异或和是否为0，在j以上位能选1就选1的情况下</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>,tmp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];<span class="comment">//读入</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">31</span>;j&gt;=<span class="number">0</span>;j--)<span class="comment">//枚举位数，此时对于所有数大于j的位能填则填1</span></span><br><span class="line"><span class="comment">//从高位向低位枚举,原因时下面当cnt==0时直接break，这是高位全填1异或和不能为0的情况</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&amp;(<span class="number">1</span>&lt;&lt;j))cnt++;<span class="comment">//统计第j位为1ll的数的数量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">tmp=<span class="number">1</span>;<span class="comment">//记录全填1的方案数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[k]&amp;(<span class="number">1ll</span>&lt;&lt;j))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//通过取余取后j位</span></span><br><span class="line">f[k][<span class="number">0</span>]=f[k<span class="number">-1</span>][<span class="number">1</span>]*(a[k]%(<span class="number">1ll</span>&lt;&lt;j)+<span class="number">1</span>)<span class="comment">//这位填1</span></span><br><span class="line">+f[k<span class="number">-1</span>][<span class="number">0</span>]*(<span class="number">1ll</span>&lt;&lt;j);<span class="comment">//这位填0</span></span><br><span class="line">f[k][<span class="number">1ll</span>]=f[k<span class="number">-1</span>][<span class="number">0</span>]*(a[k]%(<span class="number">1ll</span>&lt;&lt;j)+<span class="number">1</span>)</span><br><span class="line">+f[k<span class="number">-1</span>][<span class="number">1</span>]*(<span class="number">1ll</span>&lt;&lt;j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">f[k][<span class="number">0</span>]=f[k<span class="number">-1</span>][<span class="number">0</span>]*(a[k]%(<span class="number">1ll</span>&lt;&lt;j)+<span class="number">1</span>);<span class="comment">//因为a_k可以为0，所以要加1</span></span><br><span class="line">f[k][<span class="number">1</span>]=f[k<span class="number">-1</span>][<span class="number">1</span>]*(a[k]%(<span class="number">1ll</span>&lt;&lt;j)+<span class="number">1</span>);<span class="comment">//这位只能填0</span></span><br><span class="line">&#125;</span><br><span class="line">tmp*=(a[k]%(<span class="number">1ll</span>&lt;&lt;j)+<span class="number">1ll</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> val=<span class="number">0</span>;</span><br><span class="line">val=f[n][<span class="number">0</span>];<span class="comment">//异或和为0的方案数</span></span><br><span class="line"><span class="keyword">if</span>((!(cnt&amp;<span class="number">1ll</span>))&amp;&amp;j!=<span class="number">0</span>)<span class="comment">//第j位为1数字数量为偶数，减去全选1的方案数</span></span><br><span class="line">&#123;</span><br><span class="line">val-=tmp;</span><br><span class="line">&#125;</span><br><span class="line">val&gt;&gt;=j;<span class="comment">//最后一个数不考虑，因为前面的数确定后最后一个数就确定了</span></span><br><span class="line">ans+=val;</span><br><span class="line"><span class="keyword">if</span>(cnt&amp;<span class="number">1</span>)<span class="keyword">break</span>;<span class="comment">//如果这位1数量为偶数，则后面的都不合法，可以思考一下状态</span></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)(ans<span class="number">-1ull</span>);<span class="comment">//滑稽输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解：P10243_[THUSC_2021]__种树（通信题，暂无数据）</title>
      <link href="/2024/07/03/%E9%A2%98%E8%A7%A3%EF%BC%9AP10243%20%5BTHUSC%202021%5D%20%E7%A7%8D%E6%A0%91%EF%BC%88%E9%80%9A%E4%BF%A1%E9%A2%98%EF%BC%8C%E6%9A%82%E6%97%A0%E6%95%B0%E6%8D%AE%EF%BC%89/"/>
      <url>/2024/07/03/%E9%A2%98%E8%A7%A3%EF%BC%9AP10243%20%5BTHUSC%202021%5D%20%E7%A7%8D%E6%A0%91%EF%BC%88%E9%80%9A%E4%BF%A1%E9%A2%98%EF%BC%8C%E6%9A%82%E6%97%A0%E6%95%B0%E6%8D%AE%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>因为不要求还原树的标号，所以考虑 dfs 序，记进入一个节点为 $\texttt{(}$ ，从离开一个节点为 $\texttt{)}$ ，可以发现，这一定是一个合法的括号序列，证明如下，不太严谨，大家感性理解：</p><ol><li>当只有一个节点时，显然这是一个括号序列。</li><li>当一个节点 $u$ 有 $n$ 棵子树时，此时以 $u$ 为根的子树的括号序列即为所有子树的括号序列相接，再在外面套上代表根节点的括号，于是当所有以与 $u$ 直接相连的点为根的子树 dfs 序为括号序列时，以 $u$ 为根的子树 dfs 序是括号序列。</li></ol><p>由此可知，所有可能存在的树共有 $H_{70}$ <a href="https://oiwiki.org/math/combinatorics/catalan/">($H$指卡特兰数)</a>种，这个数是小于 $2^{128}$ 的。于是用 0 表示左括号， 1 表示右括号，便可以用 <code>__int128</code> 编码传输，解码时模拟 dfs 还原即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成都集训</title>
      <link href="/2024/04/10/20240409%E6%88%90%E9%83%BD%E9%9B%86%E8%AE%AD/"/>
      <url>/2024/04/10/20240409%E6%88%90%E9%83%BD%E9%9B%86%E8%AE%AD/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="05f29c6be7286e1f86321f23d439c348d9812e559627b09ce0183342429302de">62dc568d7543237b6f3b326f7a9507355d79e42cf115a3566cfc1745b21429cd4452d3906c0a161692f159135dd941287d486c7088309bf30a5133d6ca149bc1fee671ad15cb15637d794b85a136b76722e6a5eff31bf9397fc380407b7f7fb656670b2d098ca143718ec9537c22dca9e01f383bd9935ba6dabc853bacc802a0a45dc1a47a10c03d1e28078142971fc6f6a901bd01be213eb79ae0ecda1721e8da36652762c8a0c9a74798552857087043c3ec2935ff1baf811d5266295a29aa9bccf8fba5e5265ccf962ca126139abcecdafe51228a14235566742f309a6e053bd58fccb751a28fe234d7be13d025fe85b5d6ba5bd7d13ce9ce273e4dffbcfc7dec4dd487c291a6495cb0e2e51d9c9f15ea4545ecfa2d9fc4a6fcccae5cc8b8bfc90679ac4329f60b7efbf637e9d03479e5133347ee7cee5965671dba14d0d3245dcba218a09733d6c6e5afdc0bf1b417426ea82e04bf1d919206eb3ead345afbd58f874c9552c71351baa486c3a4850c07d4549c0a94dd2149d3fb03a083d48286a746e8c0a0b34edbab5ae539325aff583aa903c580870b84f834aa6f0a8f60ef2d228d712a78f05a9fbde6500c56e684ef6503f3a2446c457b04cecf0da834ac9405a7122a73e8218107c3fded343b0bee3c52fd0b89818548383307840a3d8dfadde23f57d003d102784591d6ac8728964be0614ba1803381965511ac3704d18882bf40def6a67d2685e89feeb64008962c576522cf2871e193cfd7cb924ab37d388dd4a87d9cd526ff5963c3a16b4898603884f7e2374c8a3c3960d07d14527276b830bfe3b9cb7a6c34aa95999e3b20350cb20ac422880d0c8c2696ee5bd644cb6e3d4032bea768c3cbab83dfb0919d03e7cf96f15adb8429885a633d27bbfaf65d777f0f1aa1d3bc5d1d333de4cdabcd75bd5aa373ace0b33b094bfef228293ad2905036d51414a18afb681857d4b7bda005e0c0fb3d9ce1a465a5a8765a844a7e41942aff628a676e0c2d4aebc1bc841bb6b3f838900a4d2c14a8b33de2019f7cfe203717401ecb5b80ff966936cb80b5baf00bfd06056e4254d3277185cd1e7e5f4458b38c36b351106c2accff866a2de174ebcb9a3c8d4106d3e8a2bff3397643f0c40266dfb20edce71e159fa753422af053a457e6935fb7c3d5d63a394524987052b49a5c5ab9d4ef888ddfebe2ad275256ebf6e345f73e4245c728e311c21b87228ee5432db15f864767ed8aad4756f3c90f5edc76bf081bba9b000831de2773eb74cdf0c147c43d1504bf93edb0c3cc4430e9a5fe2f61825159dc5bde612f3b6ef99f2841492ea3b334ec8468eda21757e7c0144cb539f9644c6ffb2d6ed5f6286900a43b02813c731e38985e738d135e5fe4fee8e01468f686642bb94b9b32af06c19b60989417027095c8d22a55d22cfd6ed0f2737c3e4f6658e46dc900c2e51887e6a58b53c9e5ab017dc010e2d6fbf4f5a7d6f1a0fc0adfff34f8b29d1f85b3d5b8e17bf63e5bfe0cecd6a11fbda32b91eee994110dab8eb22ea30ceca9178fcd0115e3fc9fb10bcd68f07ecf01eb88238647aef4a530c5ca998cacc9b0b00699176b54f4beeee361492c7904ce94cdc953b1c6d1709357c8ffdc17caef972f086b1e53d981e4559807cdc7b095477e5d97fa12bab7d4af9d49ba5ec25d804a68cf53aa38e3050de629e87ec5326c1d8bf138e919c757c379489114c7cbac4c2d9a9305d087ef3d3c9dd5b7a69aa10cc40e046567db5c1f2f39ae25808002aa3e7c501dc80e01af744a4f1fc8ef4828d08bc074b49834e2e753cffbb2c0ded10fb89591c278ce39ad779df2517e5d728312dc2623ea451c44cd8fc5b5f50567176fd4619012133f3aa22d5c751e92926a182ffc9fa2a5db68b3e4b155e960b7ddb334edde0f5d763f7696e7d7f754a070737aebaefa25597beda72284b19fe6e9c94e35bfbf25ee701de3c8b18d33e43553ad5efc3b0e0c590dca8a76d60c55159e0bfce630d5955a34ef314dafc674c53be89c720b4e87f8668487f57623d51a8b5eec6085a1309c3757914e6e9138f973779175d795372e7e3c1deabde51ce2a6807501389f37fba757a02e7922ec6178556b6a773d3f0024c100b7c28bf73b086ea45eec1a7cdf662b34f0e76a2e272d8fabc6011bb4dacd20c3c8f9e6b373cab41ead695b9a4f292a4c14eeb15e61f2d6ce6aad44b2a9f37f5284e18f4339e5c4b571d4f51c482bc54e54c41ed22e54050a5d1ab20ab51f80d7d387d2ae03e72fbc4e0b1a6b507829a8f5bfa68bea440bf11eb994f039a6c9977c8443661f1ebaf56c4ef4c78e00aca004f45ad40614133e72c4f90df62a9f0199b19c27b537573c994658c7f8986b58905c893e4f6f0bf63a9ad8445ee2618d86afb0df482574b0fed07fa548a1b46d615b71688b9134e6b44abe82c2ed607abe9ced21d71ac83fbd164cbd165e5ea2bfef05a7b63ce175456e8a663c57c66dc0f1aca4300ab3d449460bb14e06af928298d23a0f7738de078c8039b78d946733de6fef3bbdec2b30349f5948bfc5b912d0faefd83d96ae8ef13cfba420bbd461674636c8e04c54030b59b52ae072e0c4ae2653aee6e9b011676ace7d04b85bd404e7a086aef1efbc04ac290fce820374dab685a4377e9894108c671cc112446dc469b9a998ee860e252e284692dbf81cc987c0bb4a4c8f396ce4fa0779c3fed41c05bef0f71fe9e42b80f17922b8423d4555c2dbdfd9ee8c4e0d1a5ba77b845c5fc75865b66401b4e95c8ff9b9e3d708d1a2ddeb6dbea0c3089703f2c35b81954c99280ad7a3fb1e621d6d7df8fe2a86f06fef3b3e0d1f43e194e92c4f7cdf9fbbf67d8a1cf538065089870bd42754857d8ad3273037fdb1a5c938d0c644a21c1fe6a985194df453298c0c5fb915a1c21669177d971d5eb44ed1a4b161063fd020bbf15dd6ed1bc04415b4e7512946785669d490aa3898749dabc228555b7d256db371fcb31efca5fe4e52cdbebaa47625433fb7a1ad9dbe753f14153a54d139f57e58f02c9830ef16b8a7db37ebe27f29dc31cbee7b3dde5995a21919eb620bfca10d2e2a66a0332cdb0a4bbd961246506bb3dea37b51f8fd1ad3413a27b479482e3d7c7bf85894f25dfb07b348c51c84b846477f836334c19518a87999adf4d377176488264e5813756b5ba77acf172e1f934bb72b9a50aa342afffc9885fb7efe19681d625854935f1f946effeb20350a1ca616b8e692766e866c0becacb19a08e6c7f625bbe0d58af9a771efa8d60c9114f10f4909fc3ad453aee61b8e0da525b2be1b8f34a223d5198980bfbc218a14de35889b9189d7712dda460057eec77f23fe6d2717d6d685c946c2ef51e29045a99dccfb5891884b3b6c7cf9492e3e6a7c847002792cad0b71ab6183a38c29cc4161f870b4c7a3594fc809b92d01c568835711c53caf8ee35b43017ae6f7f03791e1455724110c6476dc7cff687d2c2c714bc65c3e1d1e5759b35f0fb6268c5a564d655a3d05547a342bb0b3ff5e411b9b0814a36486ca1fef104ca44e11cb15fdc717ac7d680effb4a0db5b2019febc1f9493478288d3ce0f4dbec92687242fee389cc9222ffff9310c1039909bec5282fb79322e7bb934e48ec00597f204515fc4fbf17ccd68ac067b84d5b0cf5cc7f7fbfd71eb95135dc021132f22c01e40f8584864aa0c54e1679c2e6cc46d1da14832168a440af0cea3a7f79d9a9e2c2e1182e778013a275e084db64affc194e1ca474883f96af51f44d39496739816b1df9009580b9e0025f3852b902da1c4e13897a5c336c0d38ad4a1448c43dd078e35cd09d4b12706604100a58700aeace25af72c8181c325e83a0dea5fd38b5aa519f5786343e0de1f95c7a36aefa3b4a65d7f54cdf7e4be23e6b46043078a1494bfa1751d0f9b5dd6f30d58b53a54683e553841db1d5b6a5ce89de4ad46fa066f14e4a6cd0f5b3c3e74e2a04fbf0ab2d99f739238489dfc4541d708145bb3f7cc72b7110260a34cd8a3c5cf8058b4c69d2a3468ed09c3b722f1bc28f673862bce51c1d678511bab0cce4fdb3ea4d3e61e58b17c2b394993074fcc1de113ecb079ee9cbc61e7b8a79bd932958ad8deaadc762112c5b1ab23a75c9acaf965fa2624b71348fc8bd56746cb43787aa381fad765689c791ddf72069d043040af116cf30d67c4e53a28ce78b3a7b78a419b54d4585100335feadbab1417a7e6090622678ec9b50b7856200ea743879c9b0c3a9878ac4b46a7f64920ebdfcec9c633e60218ecb3329bb3adb2fc0a70032b0d3381a3324476c9b85bd3aeed6f64f154f7c229b06a29bd3429b961ed7b211571a9f8dc02cc0cfa0143c0539c6d163e524b3aba2210576441965a54a30c1880c2f1df78702e3526f1bf6a768ff7085b942089f83e58f61cabea28f5aed15c5b3c8c514edf128444bb5e2dbd86f9dc4cc8a1fedca6a826332af03a523a176e35b8cfc654cce32cf08b453b158ac081519122e209872049a88e3253bd5fe0d75cc7086ead2685058e8f80ddb48adc87506f00a9e07e13ae022500290ac3b29df674136fa097bde1c10a8bc42b65070035e436d544fca028023fd9c21fcec6ace86cde1836936aae7a008bca6fcf831cc3d033e05f4c2f2a56f9df4e4f97a8021edace2c4fc135c286a8a182a1cc5bb348da9eaf53bc2ee82e94d67534d6c5430daec39422ac7ea99ee0ea9160b903a73d4411b1d8322a46f35745c26abc9953e8dded6d1cb855e6f84823cb516c51e8c0bd7b280f76279f0a74c2de9e475e7967f2d223d982e693a228cc2b5b3f91eaedf656ec07125890e499fa85f4139b7936183343079b229eaae5acfd5e0147964658329e026e497563d9fe10558c105b0978d989c9d0ff10f4f7babb77b3d7cc72b5c50ecadb2005ec4b22c3bbd480dcd87e389cf6e60886a4859e41a06f0707dce5e6a20d2fb1ffa945897bd5f1791e6288406117d0425b634f1f365de89bc55051584689241d5e3a8f5be1b1ecb8f43550358444c1b8911e7b57343af6c73a7e23cce24e0321a01afb676070ee7c316e5fda51c68185497bb2e8c4944907ffe6007c12be988212da9a0cbbf470b3b0de6ffcf0009c2898b3e619542b4fbb7514f246ea85a43d6117ba12883b0d03530d7087de9ca308ce8a7ea89b74e7952408ddf6b57b4296a5c574017d20b5c35dc65fa7a0e4006603b234c7f1fc32527670cb670defb72d895e71482a6481fbe80438cc5b096c07cfa084dd9d31e1c5d7125271debc2557d7acc87d3458c8f557fff339569cb11551e27362d29659b39c1cbb4696e7b1069898919547371dea352f401c6598bb04cbc61bcfbd925243b5ba9ce31dfd201829137fcd83b9e885ef41bc869603139117e1627718f0420d55cdd393a9cec0e01d2fa2887deb871265b0f0343fd56872102017622532c3ab4b4d2f0be3e7e694fcc8a5109ce8d8ce6645617efb74a3e8cfd07089742d0c88d043ab2613ad7a6a9f3fecc7902de8a955ffa2490b299c67424aa1669cd72a6c89ee35d8f9573ed98b61a84a2d30ae601ba831441f026b985d0f8808762ef9478f0b5fae67a30c297a4c58a98a47a2fe3298100d934d12bc98e165afcf3802a132f47db249efb58ad9265dad30e8339dac20ea3e881daf8a7d4a91649ef87c1bb1eb711281bca19a3099accede4285a51689387be24e0bff53ded18165186117acc8102b7e79cd8500b3b95fabc5085824c7493aa3de12e9bcfe8fdc24cb20c3804e9f28ca3b395e04432c405f14442f6f7adabb264a9ca78a56e9889a7a863d7f09dc0a56bf5cc29afbde33fba460a7a24a6757ffcb83480ac0112f983c9e34f7cd6a8a0d429e6edd91813a2d0ab81f61416dd03092f0204a14163630fc6b7b3f612a096cf7894a3c925ce9345064d5ce76c97cf3c3919f0187b2db668f2735a8d81c57911cb14a996edef1caba898f5ce093d275c2d970a60785d2f534a3c8c6d9f1839005235786f463e1daaa3260c1773b64c642f3f997b047ef2b52a7e7bef47f60b650626c1d3ff1184f9fa76014aa05ec7f66480d3ab6b7e65ec0a824d0692c9d6233429cb1e42e1b139c01458b144fa4ee18d86c59ebecb0d90e7be67a845299f8e8895d23fcb03e0febc5e5e8fc3449ecc48779422371b868157bc1cd1679087f6375a9dc795a94ad4528896487007f4f63f415f2a6d07e97bf9c9b952b361ea389f1373e6ae8086b6a2d4c16ce58e23e3b3832883d6ee2f16e8dcd798b690175dbc56729ddb91ea2ec6daa00d0284ed2e65363bf53e10365f10e62275fd3cba74fff54d8666f20d8947717a48283c4c783d4d84b11dff9c42c0bc0495c85d62e30dff3fbb283b9ee0d6318639d58a3073db28a5480db8ac336fd9dfc5313661e60129a9f708f99c138d12a3a40de148f88c40b28642a72d7cd744919907cba5b80aecf8bb18f97e40b02a1c21e2b43b758e7bf5ace5c829eaddcdb23b152e95f84ac3f7b169150d41859e8a20399ab53021c9eea4fe6bb736290f94d85e022702c994427dc4d51cf337b975d8b2fc34c41ee90007b7587161e45babbd126a942aa0ef07fc712ba3a3661848c68845bad8b1b908aab554aa2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">s2参加这次集训的初一的首字母缩写</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> -游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宿舍日志</title>
      <link href="/2024/03/21/%E5%AE%BF%E8%88%8D%E6%97%A5%E5%BF%97/"/>
      <url>/2024/03/21/%E5%AE%BF%E8%88%8D%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="09092f6c566a35338054527e0579920166a5e60d94291a1edef523849f34b3f1">48bf2b3dc5748a452040de3ea53899a162f7e3c14a7df3043052bde92e91c79980802bc2c40523afba377e4f4e85067f497378016ddc280244082356fcc3ab717b5962cdc5ad5258becba7f1b93e8e1be10c4cb9109eca54851c572e4dc3d195947d4b810211ee92e8b48eb49c85ec08df8216e72adf69dae55c9de679f0b9828bd888f0557b81e21e942301d1c86ee30df69d58b01892053008069b92c02af7270867076505359cb4258861f80f98f1f93a7bccbd4e784d2711c7e80d3910f21b16c5b72e451bde42ba1b6f0a4ee902644cc84f9d0dd409dacf6cd11b877e919d0457441059b63e96cdfd4572eef18ce3a2f9a858bf4699c2a85ad3209f9f0e71fdc0812bf68d33eaa5e6744565502b01bf1e8b284ffd29eea616de2c74549eb10c508c5fbaa119e3b662971d3b6c944e86aae02e19f8fd291891eb8f8616be03be99241c7a3bde7c7019ce5ec34b11e8c804b32936c52608d3245ceabe42ce9519640be43465a3ed0abd240d39417d800ec560c72e2fa9fdefae0390f2508a2fd85fd672dbee1c8e3368e012016db7bfb803170d11f46658fea5680940034fbe7ac18852ea8c59086fc335786a8cf102abae75d0ddf4f0f09559c18c18254a1da8154eece9e04fec8e84d1d19527692fe176e26e7daffef257071e7072ac036ffc2f0a99215a4980095fce4a874274270c9bf4f249e4fe7bf3b04890f3c1428080141419e89679d7f862d4c20c1ab755632870368aae8f9b881ca9c2ddf69aa0e0a7362ad49df316fb5e5f424237728dac6057fb211fcaddd4a071a7b0f05b181ef5286a20e650b8dd82ac58c9efc72855c0fa2b085af7b0d72e1c1be40e1b5d45caaf12b65f8b8487cc4c370e14e178ce9790479bfa824f5dd7496c73103d9f82f454c0fbc2d7c2c5439d129be92d96dfa8ec8897be65f7f0fa613e0fa084ace4e6224d0f296c6bf0a9dd70c8f4acc6f266d35e076c07efdabe463e21d90c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">hugoi's npy</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数论</title>
      <link href="/2024/03/16/%E6%95%B0%E8%AE%BA/"/>
      <url>/2024/03/16/%E6%95%B0%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h2><p><code>__gcd</code></p><h3 id="拓展欧几里得"><a href="#拓展欧几里得" class="headerlink" title="拓展欧几里得"></a>拓展欧几里得</h3><p>同余方程</p><p>$ax_1+by_1&#x3D;gcd(a,b)​$</p><p>$bx_2+(a\bmod b)y_2 &#x3D; gcd(b,a\bmod b)​$</p><blockquote><p>$ax_1+b_y1&#x3D;bx_2+(a\bmod b)y_2​$</p></blockquote><p>$ax_1+by_1&#x3D;bx_2+(a-(\lfloor \frac {a}{b} \rfloor))y_2​$</p><blockquote><p>$x_1&#x3D;y_2,y_1&#x3D;x_2-\lfloor \frac{a}{b}\rfloor y_2​$</p></blockquote><p>递归求解直到gcd为0</p><p>递归$x&#x3D;1,y&#x3D;0$回去求解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;x=<span class="number">1</span>,y=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">exgcd</span>(b,a%b);</span><br><span class="line">    <span class="type">int</span> t=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=t-(a/b)*y;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h2><p>${a \over b } \equiv a * {b^{-1}}(\bmod p)​$</p><p>其中$b^{-1}​$是$\bmod p​$意义下 b 的逆元</p><ol><li>$O(n)​$</li></ol><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)inv[i]=(p-p/i)*inv[p%i]%p;</span><br></pre></td></tr></table></figure></blockquote><ol start="2"><li>费马小定理$O(\log (n))​$</li></ol><blockquote><p>$a * a^{p-2} \equiv 1(\bmod p)(a^{p-2}为a的逆元)​$</p></blockquote><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inv[a]=<span class="built_in">qpow</span>(a,p<span class="number">-2</span>);</span><br></pre></td></tr></table></figure></blockquote><ol start="3"><li>拓展欧几里得</li></ol><blockquote><p>$ax+py&#x3D;1 $</p><p>x即为解</p></blockquote><ol start="4"><li>$O(n)​$</li></ol><blockquote><p>$s_i ​$为前i 个数前缀积</p><p>$sv_n​$为$s_n​$的逆元</p><p>$sv_n*a_n&#x3D;sv_{n-1}$</p><p>$a_i&#x3D;sv_i*s_{i-1}$</p></blockquote><hr><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><p>求ans</p><p>$ans&#x3D;\begin{cases}x \equiv b_1(\bmod a_1)  \\ x \equiv b_2(\bmod a_2)  \\  x \equiv b_3(\bmod a_3)  \\…  \\ x \equiv b_n(\bmod a_n)\end{cases}​$</p><p>$ans&#x3D;b_1 * a_2 a_3 * (a_2 * a_3) ^ {-1} (a_1 ^ {-1},a_3^{-1}为a_2,a_3 \bmod a_1下的逆元)+b_2 * a_1 a_3 * (a_1*a_3)^{-1} +b_3 * a_1 a_2 * (a_1 * a_2)^{-1}​$</p><hr><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>$\varphi(i)$ 所有&lt;&#x3D;i的与i互质的数的个数$(\varphi(1)&#x3D;1)$</p><p>积性函数：$\varphi(xy)&#x3D;\varphi(x)*\varphi (y) \ \ \ \ \ (gcd(x,y)&#x3D;&#x3D;1) ​$</p><blockquote><p>-&gt;$\varphi (p^k)&#x3D;p^k-p^{(k-1)}$</p></blockquote><blockquote><p>-&gt; $n&#x3D; \displaystyle\prod_{i&#x3D;1}^s \varphi(p_i^{k_i})$ 其中$p_i​$为n的质因子</p><p>-&gt;$\varphi(n)&#x3D;\displaystyle\prod_{i&#x3D;1}^s p_i^{k_i-1}(p_i-1) ​$</p><p>-&gt; $\varphi(n)&#x3D;n*\displaystyle\prod_{i&#x3D;1}^s(1-\frac1{p_i})​$</p></blockquote><hr><h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>若$gcd(a,m)&#x3D;1​$,则$a^{\varphi(m)}\equiv1(\bmod m)​$</p><h3 id="拓展欧拉定理"><a href="#拓展欧拉定理" class="headerlink" title="拓展欧拉定理"></a>拓展欧拉定理</h3><p>$a^b\equiv\begin{cases}  a^{b \bmod \varphi(p)} \ \ \ , \ gcd(a,p)&#x3D;&#x3D;1 \\ a^b \ \ \ \ , gcd(a,p)!&#x3D;1,b&lt;\varphi(p)  \\ a^{(b\bmod\varphi(p)) \ + \ \varphi(p)} \ \ ,gcd(a,p)!&#x3D;1 \ ,b&gt;&#x3D;\varphi(p) \end{cases} \ \ \ \ \ \ \ (\bmod p)​$</p><h2 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h2><p>根号分治的思想，$x^{a}\times x^{b\sqrt {mod}}\equiv c \bmod mod (a&lt;\sqrt {mod})$ 先枚举 $a$，用 hash 表存下来每个值对应的 $a$ ,再枚举 $b$ 去找对应值是否对应 $a$ 就可以了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> oi </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数</title>
      <link href="/2024/03/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
      <url>/2024/03/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>m行n列的二维数表</p><p>$\begin{bmatrix}a_{1,1}&amp;a_{1,2}&amp;…&amp;a_{1,n} \\ a_{2,1} &amp;…&amp;…&amp;… \\ a_{m,1}&amp;…&amp;…&amp;a_{m,n} \end{bmatrix}​$</p><p>n&#x3D;&#x3D;m时成为n阶方阵</p><p>主对角线：从左上到右下的对角线</p><p>零矩阵（全0）$O_{m \times n}​$</p><p>单位阵$I_n​$n阶方阵主对角线为1，其余为0</p><p>对角阵$A_n$n阶方阵，记$A_n&#x3D;diag(x_1,x_2,…,x_n)$只有主对角线不为0</p><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="加减"><a href="#加减" class="headerlink" title="加减"></a>加减</h3><p>对应位置元素相加相减</p><p>有交换律，结合律</p><h3 id="乘"><a href="#乘" class="headerlink" title="乘"></a>乘</h3><p>前提：第一个矩阵的列数&#x3D;&#x3D;第二个矩阵的行数</p><p>用$\triangleq$表示</p><p>$AB&#x3D;\begin{bmatrix}a_{1,1}&amp;…&amp;… &amp;a_{1,s} \\ a_{i,1}&amp;…&amp;…&amp;a_{i,s} \\ …&amp;…&amp;…&amp;a_{m,s}  \end{bmatrix}\begin{bmatrix}b_{1,1}&amp;… &amp;b_{1,n} \\ b_{i,1}&amp;…&amp;b_{i,n} \\ …&amp;…&amp;… \\ …&amp;…&amp;b_{s,n}  \end{bmatrix}\triangleq \begin{bmatrix}c_{1,1}&amp;…&amp;… &amp;… \\ c_{i,1}&amp;…&amp;…&amp;c_{i,n} \\ …&amp;…&amp;…&amp;… \\ …&amp;…&amp;…&amp;c_{m,n}  \end{bmatrix}&#x3D;C$</p><p>$c_{i,j}\triangleq a_{i,1}b_{1,j}+a_{i,2}b_{2,j}+…+a_{i,s}b{s,j}​$</p><p>$A \  \times  \ B \ &#x3D; \ C  \\  m  \times  s \ \ s  \times  n \ \ \ m  \times  n$</p><p>$c_{i,j}&#x3D;\displaystyle\sum_{k&#x3D;1}^{s}a[i][k] \times b[k][i]​$</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>$AB&#x3D;0未必A&#x3D;0或B&#x3D;0​$</p><p>$AB未必等于BA​$</p><p>$AB&#x3D;AC未必B&#x3D;C​$</p><p>若$AB&#x3D;BA​$则称A和B可交换</p><p>$A_{m,n}  \times  I_n &#x3D; A , I_m  \times  A_{m,n} &#x3D; A​$</p><h5 id="幂运算"><a href="#幂运算" class="headerlink" title="幂运算"></a>幂运算</h5><p>必为方阵</p><p>$A^kA^t&#x3D;A^{k+t},(A^k)^t&#x3D;A^{kt},(AB)^k\ne A^kB^k$</p><p>可以快速幂</p><h3 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h3><p>$\begin{bmatrix}a&amp;b &amp;c \\ d&amp;e&amp;e \end{bmatrix}^T\triangleq \begin{bmatrix}a&amp;d \\ b &amp; e \\ c&amp;f \end{bmatrix}​$</p><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><p>$(A^T)^T&#x3D;A,(A+B)^T&#x3D;A^T+B^T,(AB)^T&#x3D;B^TA^T​$</p><h2 id="递推式"><a href="#递推式" class="headerlink" title="递推式"></a>递推式</h2><p>确定递推向量</p><p>例子：</p><blockquote><p>$a&#x3D;b+c \times 2$</p><p>$b&#x3D;c*2$</p><p>$c&#x3D;b+1$</p><p>$\gets​$</p><p>$\begin{bmatrix}a&amp;0 &amp;0&amp;0 \\ b&amp;0&amp;0&amp;0 \\ c&amp;0&amp;0&amp;0 \\ 1&amp;0&amp;0&amp;0 \end{bmatrix} \triangleq\begin{bmatrix}0&amp;1 &amp;2&amp;0 \\ 0&amp;0&amp;2&amp;0 \\ 0&amp;1&amp;0&amp;1 \\ 0&amp;0&amp;0&amp;1 \end{bmatrix}$</p></blockquote><p>转移矩阵各行即每一项对应的递推公式</p><h5 id="有常数，补一项"><a href="#有常数，补一项" class="headerlink" title="有常数，补一项"></a>有常数，补一项</h5><h5 id="有常数幂次，补一项，转移矩阵对应项有常数"><a href="#有常数幂次，补一项，转移矩阵对应项有常数" class="headerlink" title="有常数幂次，补一项，转移矩阵对应项有常数"></a>有常数幂次，补一项，转移矩阵对应项有常数</h5><h5 id="有一次项，补一"><a href="#有一次项，补一" class="headerlink" title="有一次项，补一"></a>有一次项，补一</h5><h5 id="有二次项，补一个一次项"><a href="#有二次项，补一个一次项" class="headerlink" title="有二次项，补一个一次项"></a>有二次项，补一个一次项</h5><h2 id="路径条数"><a href="#路径条数" class="headerlink" title="路径条数"></a>路径条数</h2><p>转换为递推式即可。注意走到就停和走过。</p><h2 id="优化-dp"><a href="#优化-dp" class="headerlink" title="优化 dp"></a>优化 dp</h2><p>每一次快速幂优化一层循环，比较套路，状态数有几维很少，其余很多就可做。</p><p>还没场切过 ddp ，希望下次遇到能记起来吧。</p><h2 id="min-矩阵-max-矩阵"><a href="#min-矩阵-max-矩阵" class="headerlink" title="min+ 矩阵 max+ 矩阵"></a>min+ 矩阵 max+ 矩阵</h2><p>神奇的结合律。</p><p>$res_{i,j}&#x3D;\displaystyle\min_{k&#x3D;0}^n a_{i,k}+b_{k,j}$</p>]]></content>
      
      
      
        <tags>
            
            <tag> oi </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合数学</title>
      <link href="/2024/03/16/%E7%BB%84%E5%90%88/"/>
      <url>/2024/03/16/%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="排列数"><a href="#排列数" class="headerlink" title="排列数"></a>排列数</h2><p>$A_n^m或P_n^m$</p><p>$A_n^m&#x3D;n(n-1)(n-2)…(n-m+1)&#x3D;\frac{n!}{(n-m)!}​$</p><p>从n个不同元素中取m个元素，考虑顺序</p><h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><p>$\binom {n}{m}&#x3D;C_n^m&#x3D;\frac{A_n^m}{m!}&#x3D;\frac{n!}{m!(n-m)!}$</p><p>从n个不同元素取m个元素组成一个集合，不考虑顺序（也被称为二项式系数）</p><h3 id="二项式定理"><a href="#二项式定理" class="headerlink" title="二项式定理"></a>二项式定理</h3><p>${(a+b)}^n&#x3D;\displaystyle\sum_{i&#x3D;0}^n{\binom {n}{i}}{a^{n-i}b^i}​$</p><h5 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h5><p>归纳$\binom {n}{k}+\binom {n}{k-1}&#x3D;\binom {n+1}{k}$</p><h3 id="多重集合排列"><a href="#多重集合排列" class="headerlink" title="多重集合排列"></a>多重集合排列</h3><p>同一集合元素相同，从k个集合取全部元素的排列方案，考虑顺序</p><p>sum为元素总数     $n_i​$为第i个集合元素个数     k为集合个数</p><p>$\frac{n!}{\displaystyle\prod_{i&#x3D;1}^{n!}{n_i!}}&#x3D;\frac{n!}{n_1!n_2!…n_k!}​$</p><h3 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h3><p>n个球放m个不同的盒子中，放完，每个盒子放任意数量的球，考虑顺序</p><p>插板法</p><p>n球放m盒，插$m-1$个板，盒子不能空，$\binom {n-1}{m-1}$</p><p>盒子可空$\binom {n+m-1} {m-1}​$ 即$x_1+x_2+x_3+…+x_m&#x3D;n​$的非负整数解数目</p><h3 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h3><p>将n个物体划分成k个非空的没有区别的集合的方案数  (球不同盒子相同，无顺序，非空)</p><p>递推<code>S2[i][j]=s2[i-1][j]*j+s2[i-1][j-1]​</code></p><p>$S_{i,j}&#x3D;S_{i-1,j}*j+S_{i-1,j-1}$</p><p>通项$s2(n,m)&#x3D;\frac{1}{m!}*\displaystyle\sum_{k&#x3D;0}^m (-1)^k\binom {m}{k}(m-k)^n$</p><h3 id="贝尔数"><a href="#贝尔数" class="headerlink" title="贝尔数"></a>贝尔数</h3><p>第二类斯特兰数二维前缀和</p><p>将n个物体划分成k个可空没有区别的集合的方案数  (球不同盒子相同，无顺序，可空)</p><p>$B_{n+1}&#x3D;\displaystyle\sum_{k&#x3D;0}^n\binom {n}{k}B_k&#x3D;\displaystyle\sum_{k&#x3D;0}^n\binom{n} {k}B_{n-k}$</p><h2 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h2><p>求大组合数，模较小质数</p><p>$\binom{n}{m}\bmod p&#x3D;\binom{\lfloor n&#x2F;p\rfloor}{\lfloor m&#x2F;p\rfloor }*\binom{n\bmod p}{m\bmod p}\bmod p$</p><p>对于$\binom {\lfloor n&#x2F;p\rfloor}{\lfloor m&#x2F;p\rfloor}$递归处理</p><p>对于$\binom {n\bmod p}{m\bmod p}​$预处理</p><p>$O(p+log(n))​$</p><p>模数不是质数，中国剩余定理</p><p>$\begin{cases}\binom{n}{m}\bmod p_1^{k_1}&#x3D;x_1 \\ \binom{n}{m} \bmod p_2^{k_2}&#x3D;x_2 \end{cases}$</p><h2 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h2><p>比较重要，特别是你这个菜鸡不会容斥的时候。</p><p>跟别的博客很像，设 $f_i​$ 表示恰好 $i​$ 个的方案数（恰好 $i​$ 个什么？别管，做题就知道了），$g_i​$ 表示至少 $i​$ 个的方案数（使用更多的，钦定 $i​$ 一定有）。</p><p>那么</p><p>$f_k&#x3D;\displaystyle\sum_{i&#x3D;k}^ng_i​$</p><p>$g_k&#x3D;\displaystyle\sum_{i&#x3D;k}^n(-1)^{i-k} \binom{i}{k}f_i$</p><h3 id="拓展卢卡斯"><a href="#拓展卢卡斯" class="headerlink" title="拓展卢卡斯"></a>拓展卢卡斯</h3><p>不会</p>]]></content>
      
      
      
        <tags>
            
            <tag> oi </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello_World</title>
      <link href="/2024/03/16/hello-world/"/>
      <url>/2024/03/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> -tset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new</title>
      <link href="/2024/03/16/new/"/>
      <url>/2024/03/16/new/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> -new </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3551题解</title>
      <link href="/2024/03/16/%E9%A2%98%E8%A7%A3_P3551_%5BPOI2013%5D_USU-Take-out/"/>
      <url>/2024/03/16/%E9%A2%98%E8%A7%A3_P3551_%5BPOI2013%5D_USU-Take-out/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个01串，每次操作消除 k 个1和1个0，每次操作的涉及的最左和最右的字符中间不得有消除过的串，求消除方案。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>可以认为有两个约束条件</p><ol><li>不得经过消除过的串</li><li>每次消 k 个1和1个0</li></ol><p>对于第二个条件，只要找出k个1和1个0即可，难点在于第一个条件。</p><p>首先考虑划分成几个区间，从两边消到中间。</p><p>这时就会出现一个问题，每次的 k 个1有多个位置可选，如果选择不当，下次消除 k 个之后也有可能消不到一个0.</p><p>比如这样(k&#x3D;2)</p><blockquote><p>bbbbccccbbbbcbb</p></blockquote><p>选择前两个，会发现两端没有 c 可选。</p><blockquote><p>xxbbccccbbbbcbb</p></blockquote><p>也可能出现这种情况(k&#x3D;2)</p><blockquote><p>bbbccbbccbbb</p></blockquote><p>需要划分成两段</p><blockquote><p>bbbccb | bccbbb</p></blockquote><p><strong>所以考虑将这个过程反过来</strong>  从中间往两边消，最后逆序输出答案，这样就避免了1条件的限制。</p><p>很明显，每次$O(n)$找可消除的串再拼接要 T 爆了，于是考虑遍历一遍，对于每个位置 i 考虑包括 i 的前 k+1 个未消除的字符能否消除。因为一定有解，所以这种方法可以消除完整个序列。</p><p>用一个栈维护 i 前面未消除的字符，同时记录每个未消除字符前有多少0和1，i 前面的0 1数量直接从上一个字符转移，如果能消除则 pop k+1 个元素。</p><p>$bbbccbbcb$</p><blockquote><p>bbb</p></blockquote><blockquote><p>bbbc -&gt; bxxx</p><p>bxxxcb</p><p>bxxxcbb -&gt; bxxxxxx</p><p>bxxxxxxcb-&gt;xxxxxxxxx</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span><span class="comment">//未消除的砖结构体</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">bool</span> cc;<span class="comment">//是否为黑砖</span></span><br><span class="line"><span class="type">int</span> b,c;<span class="comment">//此砖前k+1个未消除的砖白砖和黑砖数量</span></span><br><span class="line"><span class="type">int</span> pos;<span class="comment">//位置</span></span><br><span class="line">&#125;;</span><br><span class="line">deque&lt;node&gt; s;<span class="comment">//deque代替栈</span></span><br><span class="line"><span class="type">int</span> n,c,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans[N];<span class="comment">//记录答案</span></span><br><span class="line"><span class="type">int</span> cnt;<span class="comment">//消除次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;b;</span><br><span class="line">c=<span class="number">1</span>;</span><br><span class="line">s.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;);<span class="comment">//加空元素，避免栈空re</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> c1;</span><br><span class="line">cin&gt;&gt;c1;</span><br><span class="line"><span class="keyword">if</span>(c1==<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">s.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>,s.<span class="built_in">back</span>().b+<span class="number">1</span>,s.<span class="built_in">back</span>().c,i&#125;);<span class="comment">//此砖白</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">s.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>,s.<span class="built_in">back</span>().b,s.<span class="built_in">back</span>().c+<span class="number">1</span>,i&#125;);<span class="comment">//此砖黑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((<span class="type">int</span>)s.<span class="built_in">size</span>()&gt;c+b+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s[(<span class="type">int</span>)s.<span class="built_in">size</span>()-c-b<span class="number">-1</span>].cc)s.<span class="built_in">back</span>().b--;<span class="comment">//白砖或黑砖数减 这k+1块砖前面一个砖的颜色</span></span><br><span class="line"><span class="keyword">else</span> s.<span class="built_in">back</span>().c--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((<span class="type">int</span>)s.<span class="built_in">size</span>()&gt;c+b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((<span class="type">int</span>)s.<span class="built_in">back</span>().c==c&amp;&amp;(<span class="type">int</span>)s.<span class="built_in">back</span>().b==b)<span class="comment">//这k+1块砖是否符合要求，如果是统计答案并pop</span></span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line"><span class="type">int</span> t=s.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=t-c-b;i&lt;t;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans[cnt].<span class="built_in">push_back</span>(s.<span class="built_in">back</span>().pos);</span><br><span class="line">s.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=cnt;i&gt;=<span class="number">1</span>;i--)<span class="comment">//倒序输出每次操作</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">stable_sort</span>(ans[i].<span class="built_in">begin</span>(),ans[i].<span class="built_in">end</span>());<span class="comment">//每次操作内正序输出</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="type">int</span>)ans[i].<span class="built_in">size</span>();j++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;ans[i][j]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2024/03/06/test/"/>
      <url>/2024/03/06/test/</url>
      
        <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr><hr><h2 id="a"><a href="#a" class="headerlink" title="a"></a>a</h2><h2 id="a-a"><a href="#a-a" class="headerlink" title="|| a || a"></a>|| a || a</h2><p>$123$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set strict-ssl false </span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/wufengfeng130/article/details/131251961">use</a></p><p><a href="https://butterfly.js.org/posts/4aa8abbe/#%E8%8F%9C%E5%96%AE-%E7%9B%AE%E9%8C%84">use</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
